<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Widget Viagens ‚Äì Completo</title>
<style>
    .country-flag{width:18px;height:14px;object-fit:cover;border-radius:2px;margin-left:6px;}
    body { font-family: Arial, sans-serif; background: #0d0d0d; color: #ffffff; padding: 25px; }
    #next-destination { background: #1f1f1f; border: 1px solid #333; padding: 12px 16px; border-radius: 10px; margin-bottom: 18px; font-size: 1.05rem; text-align: center; }
    #trips-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; width: 100%; }
    .trip-card { background: #141414; border: 1px solid #262626; border-radius: 12px; padding: 14px; box-shadow: 0 0 8px rgba(0,0,0,0.6); text-align: left; display:flex; flex-direction:column; gap:8px; }
    .title-row { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .title-row h3 { margin:0; font-size:1rem; display:flex; align-items:center; gap:6px; }
    .date-info { color:#27ae60; font-size:.88rem; }
.progress-wrapper { position:relative; height:26px; background:#222; border-radius:20px; overflow:hidden; margin-top:6px; }
	.progress-fill { position:absolute; left:0; top:0; height:100%; width:0%; transition: width .6s linear, background .3s linear; }
	.progress-percent { position:absolute; right:8px; top:50%; transform: translateY(-50%); font-size:.78rem; font-weight:600; color:#ffffff; text-shadow:0 1px 2px rgba(0,0,0,0.6); z-index: 10; }
	.extra-msg-overlay { position:absolute; left:0; right:0; text-align:center; font-size:.78rem; font-weight:600; color:#ffffff; text-shadow:0 1px 2px rgba(0,0,0,0.6); }
    .emoji-icon { position:absolute; top:50%; transform:translateY(-50%); font-size:20px; transition: left .5s ease, transform .25s ease; }
    .emoji-jump { animation: jump .6s infinite alternate; }
    @keyframes jump { from { transform: translateY(-50%); } to { transform: translateY(-80%); } }
.status { color:#e6e6e6; font-weight:600; font-size:.9rem; }
	.sub { color:#bdbdbd; font-size:.82rem; }e-info { color:#bdbdbd; font-size:.9rem; margin-top:4px; display:flex; align-items:center; gap:8px; }
</style>
</head>
<body>

<div id="next-destination">Pr√≥ximo destino: carregando...</div>
<div id="trips-container"></div>

<script>
const FLAGS = {
    'Guarulhos': 'https://flagcdn.com/w20/br.png',
    'Lisboa': 'https://flagcdn.com/w20/pt.png',
    'Madri': 'https://flagcdn.com/w20/es.png',
    'Paris': 'https://flagcdn.com/w20/fr.png',
    'Londres': 'https://flagcdn.com/w20/gb.png',
    'Roma': 'https://flagcdn.com/w20/it.png',
    'Mil√£o': 'https://flagcdn.com/w20/it.png',
    'Civitavecchia': 'https://flagcdn.com/w20/it.png',
    'Val√™ncia': 'https://flagcdn.com/w20/es.png',
    'Barcelona': 'https://flagcdn.com/w20/es.png',
    'Marselha': 'https://flagcdn.com/w20/fr.png',
    'G√™nova': 'https://flagcdn.com/w20/it.png',
    'Livorno': 'https://flagcdn.com/w20/it.png'
};

const TRIPS = [
    { title: "Guarulhos ‚Üí Lisboa", emoji: "‚úàÔ∏è", date: "2025-12-19T16:20:00", arrival: "05:15", type: "flight" },
    { title: "Lisboa ‚Üí Madri", emoji: "‚úàÔ∏è", date: "2025-12-23T18:00:00", arrival: "20:20", type: "flight" },
    { title: "Madri ‚Üí Paris", emoji: "‚úàÔ∏è", date: "2025-12-27T14:25:00", arrival: "16:30", type: "flight" },
    { title: "Paris ‚Üí Londres", emoji: "üöÑ", date: "2026-01-02T16:12:00", arrival: "17:30", type: "train" },
    { title: "Londres ‚Üí Roma", emoji: "‚úàÔ∏è", date: "2026-01-08T16:40:00", arrival: "22:40", scale: "Escala em Mil√£o (19:30‚Äì21:30)", type: "flight" },
    { title: "Civitavecchia", emoji: "üö¢", date: "2026-01-15T11:00:00", embark: "11:00", depart: "2026-01-15T19:00:00", type: "cruise-start" },
    { title: "Val√™ncia", emoji: "üõ≥Ô∏è", date: "2026-01-17T07:00:00", type: "cruise-stop", depart: "2026-01-17T21:00:00" },
    { title: "Barcelona", emoji: "üõ≥Ô∏è", date: "2026-01-18T08:00:00", type: "cruise-stop", depart: "2026-01-18T18:00:00" },
    { title: "Marselha", emoji: "üõ≥Ô∏è", date: "2026-01-19T08:00:00", type: "cruise-stop", depart: "2026-01-19T18:00:00" },
    { title: "G√™nova", emoji: "üõ≥Ô∏è", date: "2026-01-20T08:00:00", type: "cruise-stop", depart: "2026-01-20T19:00:00" },
    { title: "Livorno", emoji: "üõ≥Ô∏è", date: "2026-01-21T07:00:00", type: "cruise-stop", depart: "2026-01-21T20:00:00" },
    { title: "Civitavecchia", emoji: "üö¢", date: "2026-01-22T07:00:00", arrival: "07:00", type: "cruise-end" },
    { title: "Roma ‚Üí Madri", emoji: "‚úàÔ∏è", date: "2026-01-22T14:45:00", arrival: "17:20", type: "flight" },
    { title: "Madri ‚Üí Lisboa", emoji: "‚úàÔ∏è", date: "2026-01-22T21:10:00", arrival: "21:35", type: "flight" },
    { title: "Lisboa ‚Üí Guarulhos", emoji: "‚úàÔ∏è", date: "2026-01-22T23:30:00", arrival: "06:50", type: "flight" }
];

const MAX_WINDOW_MS = 30 * 24 * 60 * 60 * 1000;

function cleanLocation(raw){
    return raw
        .replace(/[‚òÄ-‚ûø]/g, '')
        .replace(/[()]/g, '')
        .replace(/‚Äì.*/g, '')
        .trim();
}


/**
 * Extrai os hor√°rios de chegada e partida da escala.
 * @param {object} trip - O objeto da viagem.
 * @returns {{arrive1: string, depart2: string, location: string}|null}
 */
function parseScaleTimes(trip) {
    if (!trip.scale) return null;
    const match = trip.scale.match(/Escala em (.+?) \((.+?)‚Äì(.+?)\)/);
    if (!match) return null;
    return {
        location: match[1],
        arrive1: match[2],
        depart2: match[3]
    };
}

/**
 * Cria um objeto Date completo a partir de uma data base e uma string de hora (HH:MM).
 * @param {Date} baseDate - A data base (geralmente a data de partida).
 * @param {string} timeStr - A string de hora (HH:MM).
 * @returns {Date}
 */
function createDateFromTime(baseDate, timeStr) {
    const [h, m] = timeStr.split(':').map(Number);
    const newDate = new Date(baseDate);
    newDate.setHours(h, m, 0, 0);
    return newDate;
}
function getOriginDest(title){
    if(title.includes('‚Üí')){
        const parts = title.split('‚Üí').map(p=>cleanLocation(p));
        return { from: parts[0].trim(), to: parts[1].trim() };
    }
    const single = cleanLocation(title);
    return { from: single, to: single };
}
function flagForUrl(loc){ return FLAGS[loc] || null; }
function clamp(v, a=0, b=100){ return Math.max(a, Math.min(b, v)); }
function getColorForTimeLeft(msLeft){
    const DAY_MS = 86400000;
    const daysLeft = msLeft / DAY_MS;

    if(msLeft <= 0) return "#27AE60"; // Conclu√≠do
    if(daysLeft <= 9) return "#33FF33"; // 0 a 9 dias (Verde Lim√£o)
    if(daysLeft <= 20) return "#A8E61D"; // 10 a 20 dias (Verde Pistache)
    if(daysLeft <= 30) return "#E74C3C"; // 21 a 30 dias (Vermelho)
    return "#4b6b82"; // Mais de 30 dias (Azul/Cinza Padr√£o)
}
function formatCountdown(target, now){ const diff = target - now; if(diff <= 0) return "0 dias 0h 0m 0s";
    const s = Math.floor(diff/1000);
    const dias = Math.floor(s / 86400);
    const h = Math.floor((s % 86400) / 3600);
    const m = Math.floor((s % 3600) / 60);
    const sec = s % 60;
    return `${dias} dias ${h}h ${m}m ${sec}s`;
}

/**
 * Cria o elemento HTML est√°tico do cart√£o de viagem.
 * Os elementos din√¢micos recebem classes para f√°cil acesso.
 */
function createTripCard(trip) {
    const odCard = getOriginDest(trip.title);
    let originFlagUrl = flagForUrl(odCard.from);
    if(trip.type === "cruise-stop" || trip.type === "cruise-start" || trip.type === "cruise-end") originFlagUrl = null;
    const destFlagUrl = flagForUrl(odCard.to);
    const destFlag = destFlagUrl ? `<img class='country-flag' src='${destFlagUrl}' />` : '';
    const originFlag = originFlagUrl ? `<img class='country-flag' src='${originFlagUrl}' />` : '';

    const card = document.createElement('div');
    card.className = 'trip-card';

    // T√≠tulo e data
    const titleHtml = (trip.type === "cruise-stop" || trip.type === "cruise-start" || trip.type === "cruise-end")
        ? `${odCard.to}${destFlag}`
        : `${originFlag}${odCard.from} ‚Üí ${odCard.to}${destFlag}`;

    const targetDate = new Date(trip.date).toLocaleDateString('pt-BR');

    card.innerHTML = `
        <div class="title-row">
            <h3>${titleHtml}</h3>
            <div class="sub">${targetDate}</div>
        </div>
        ${trip.scale ? `<div class="scale-info">‚úàÔ∏è <i>${trip.scale}</i></div>` : ''}

<div class="progress-wrapper">
	            <div class="progress-fill" data-dynamic="fill">
	                <div class="extra-msg-overlay" data-dynamic="extra-msg"></div>
	            </div>
	            <div class="progress-percent" data-dynamic="percent">0%</div>
	            <div class="emoji-icon" data-dynamic="emoji">${trip.type === 'train' ? 'üöÜ' : trip.type.startsWith('cruise') ? 'üö¢' : '‚úàÔ∏è'}</div>
	        </div>

	        <div class="status" data-dynamic="status"></div>
	        <div class="sub countdown" data-dynamic="countdown" style="color:#27ae60"></div>
    `;

    return card;
}

/**
 * Atualiza os elementos din√¢micos de um cart√£o de viagem.
 */
function updateTripCard(cardElement, trip, now) {
    const target = new Date(trip.date);
    const msLeft = target - now;

    // 1. C√°lculo do Progresso
    let progressPct = 0;
    const windowStart = target.getTime() - MAX_WINDOW_MS;
    if(msLeft <= 0) progressPct = 100;
    else progressPct = clamp(((MAX_WINDOW_MS - msLeft) / MAX_WINDOW_MS) * 100, 0, 100);

    const color = getColorForTimeLeft(msLeft > MAX_WINDOW_MS ? MAX_WINDOW_MS : msLeft);
    const emojiLeft = `calc(${progressPct}% - 10px)`;

    // 2. C√°lculo do Status
    let status = (()=>{
        if(trip.type === "cruise-start")
            return `Embarque previsto: ${trip.embark} ‚Äî Partida: ${new Date(trip.depart).toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'})}`;
        if(trip.type === "cruise-end")
            return `Chegada prevista: ${trip.arrival}`;
        if(trip.type === "cruise-stop")
            return `Chegada prevista: ${target.toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'})} ‚Äî Partida prevista: ${new Date(trip.depart).toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'})}`;
        if(trip.arrival)
            return `Partida prevista: ${target.toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'})} ‚Äî Chegada prevista: ${trip.arrival}`;
        return `Partida prevista: ${target.toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'})}`;
    })();

    let extraMsg = "";
	const DAY_MS = 86400000;
	const daysLeft = msLeft / DAY_MS;

	if (daysLeft <= 7 && daysLeft > 0) {
	    extraMsg = "A sua viagem est√° chegando!";
	}
    
    // L√≥gica de status para Voos e Trens (incluindo escala)
    if(trip.type === "flight" || trip.type === "train"){
        const departTime = new Date(trip.date);
        const arrTime = new Date(trip.date);
        
        // L√≥gica de escala
        const scaleInfo = parseScaleTimes(trip);
        if (scaleInfo) {
            const T1_depart = new Date(trip.date);
            const T1_arrive = createDateFromTime(T1_depart, scaleInfo.arrive1);
            const T2_depart = createDateFromTime(T1_depart, scaleInfo.depart2);
            const T2_arrive = createDateFromTime(T1_depart, trip.arrival);

            // Ajusta as datas para o dia seguinte se a hora for menor que a de partida (voo noturno)
            if (T1_arrive < T1_depart) T1_arrive.setDate(T1_arrive.getDate() + 1);
            if (T2_depart < T1_depart) T2_depart.setDate(T2_depart.getDate() + 1);
            if (T2_arrive < T1_depart) T2_arrive.setDate(T2_arrive.getDate() + 1);

            // 1. Antes do primeiro trecho (Londres -> Mil√£o)
            if (now < T1_depart - 3600000) {
                // Status padr√£o (contagem regressiva)
            }
            // 2. Hora de embarcar (Londres)
            else if (now >= T1_depart - 3600000 && now < T1_depart) {
                extraMsg = "Hora de Embarcar";
            }
            // 3. Primeiro trecho em voo (Londres -> Mil√£o)
            else if (now >= T1_depart + 1800000 && now < T1_arrive + 3600000) {
                extraMsg = "Embarque conclu√≠do. Boa viagem!";
            }
            // 4. Primeiro trecho conclu√≠do (Chegada em Mil√£o)
            else if (now >= T1_arrive + 3600000 && now < T2_depart - 3600000) {
                extraMsg = "Primeiro trecho conclu√≠do";
            }
            // 5. Hora de embarcar novamente (Mil√£o)
            else if (now >= T2_depart - 3600000 && now < T2_depart) {
                extraMsg = "Hora de embarcar novamente";
            }
            // 6. Segundo trecho em voo (Mil√£o -> Roma)
            else if (now >= T2_depart + 1800000 && now < T2_arrive + 3600000) {
                extraMsg = "Embarque conclu√≠do. Boa viagem!";
            }
            // 7. Viagem conclu√≠da (Chegada em Roma)
            else if (now >= T2_arrive + 3600000) {
                extraMsg = "Viagem conclu√≠da";
            }
            
        } else {
            // L√≥gica para voos sem escala (original)
            if(trip.arrival){
                const [ah, am] = trip.arrival.split(":").map(Number);
                arrTime.setHours(ah, am);
                if(arrTime < departTime) arrTime.setDate(arrTime.getDate() + 1);
            }
            if(now >= departTime - 3600000 && now < departTime)
                extraMsg = "Hora de Embarcar";
            else if(now >= departTime + 1800000 && now < arrTime + 3600000)
                extraMsg = "Embarque conclu√≠do. Boa viagem!";
        else if(now >= arrTime + 3600000)
            extraMsg = "Viagem conclu√≠da";
        } // Fecha o 'else' do 'if (scaleInfo)'
    } // Fecha o 'if(trip.type === "flight" || trip.type === "train")'
    
    // L√≥gica de status para Cruzeiros
    else if (trip.type.startsWith("cruise")) {
        const target = new Date(trip.date);
        
        if (trip.type === "cruise-start") {
            const departTime = new Date(trip.depart);
            const embarkTime = createDateFromTime(target, trip.embark);
            const prepareTime = new Date(target);
            prepareTime.setHours(10, 30, 0, 0); // 10:30
            const enjoyTime = new Date(target);
            enjoyTime.setHours(12, 0, 0, 0); // 12:00
            const soonTime = new Date(target);
            soonTime.setHours(18, 0, 0, 0); // 18:00
            
            if (now >= prepareTime && now < enjoyTime) {
                extraMsg = "Prepare-se para embarcar";
            } else if (now >= enjoyTime && now < soonTime) {
                extraMsg = "Embarque conclu√≠do, aproveite o navio!";
            } else if (now >= soonTime && now < departTime) {
                extraMsg = "O navio vai partir em breve";
            } else if (now >= departTime) {
                extraMsg = "Embarque conclu√≠do, boa viagem";
            }
        }
        
        else if (trip.type === "cruise-stop") {
            const departTime = new Date(trip.depart);
            const arriveTime = target;
            const hourBeforeDepart = new Date(departTime.getTime() - 3600000); // 1 hora antes
            const halfHourAfterDepart = new Date(departTime.getTime() + 1800000); // 30 minutos depois
            
            const odCard = getOriginDest(trip.title);
            const city = odCard.to;
            
            if (now >= arriveTime && now < hourBeforeDepart) {
                extraMsg = `Seja bem-vindo √† ${city}, aproveite o passeio`;
            } else if (now >= hourBeforeDepart && now < departTime) {
                extraMsg = "Hora de embarcar";
            } else if (now >= departTime && now < halfHourAfterDepart) {
                extraMsg = "Embarque conclu√≠do, boa viagem";
            } else if (now >= halfHourAfterDepart) {
                extraMsg = "Viagem conclu√≠da";
            }
            
            // L√≥gica para marcar paradas anteriores como "Viagem conclu√≠da"
            // Isso requer que o status de "Viagem conclu√≠da" seja persistente, o que n√£o √© o caso
            // do extraMsg. Para simular, vamos alterar o status principal (status)
            // se a viagem j√° tiver terminado.
            // No entanto, a l√≥gica de status principal j√° √© est√°tica.
            // A maneira mais simples de fazer isso √© garantir que o cart√£o da parada anterior
            // n√£o seja mais exibido se a parada atual j√° tiver chegado.
            // Como o TRIPS √© fixo, vamos apenas 
        }
        
        else if (trip.type === "cruise-end") {
            const arriveTime = target;
            const hourAfterArrive = new Date(arriveTime.getTime() + 3600000); // 1 hora depois
            
            if (now < arriveTime) {
                // Status padr√£o (contagem regressiva)
            } else if (now >= arriveTime && now < hourAfterArrive) {
                extraMsg = "Chegada ao destino final";
            } else if (now >= hourAfterArrive) {
                extraMsg = "Viagem conclu√≠da";
            }
        }
    }
    
    // 3. Atualiza√ß√£o dos Elementos
    const fillElement = cardElement.querySelector('[data-dynamic="fill"]');
    const percentElement = cardElement.querySelector('[data-dynamic="percent"]');
    const extraMsgElement = cardElement.querySelector('[data-dynamic="extra-msg"]');
    const emojiElement = cardElement.querySelector('[data-dynamic="emoji"]');
    const statusElement = cardElement.querySelector('[data-dynamic="status"]');
    const countdownElement = cardElement.querySelector('[data-dynamic="countdown"]');

    fillElement.style.width = `${progressPct}%`;
    fillElement.style.backgroundColor = color;
    percentElement.textContent = `${Math.round(progressPct)}%`;
    statusElement.textContent = status;
    
    if(extraMsg){
        extraMsgElement.textContent = extraMsg;
        extraMsgElement.style.display = 'block';
        percentElement.style.display = 'none';
    } else {
        extraMsgElement.textContent = '';
        extraMsgElement.style.display = 'none';
        // Oculta a porcentagem se o progresso for 100%
        percentElement.style.display = (progressPct >= 100) ? 'none' : 'block';
    }

    // Posi√ß√£o e anima√ß√£o do emoji
    emojiElement.style.left = emojiLeft;
    if(progressPct > 0 && progressPct < 100){
        emojiElement.classList.add('emoji-jump');
    } else {
        emojiElement.classList.remove('emoji-jump');
    }

    // Contagem regressiva
    if(msLeft > 0){
        countdownElement.textContent = formatCountdown(target.getTime(), now.getTime());
        countdownElement.style.color = color;
    } else {
        countdownElement.textContent = "Viagem Conclu√≠da!";
        countdownElement.style.color = "#27AE60";
    }
}

/**
 * Encontra a pr√≥xima viagem e atualiza o elemento #next-destination.
 */
function findNextTrip(now) {
    let nextTrip = null;
    let minMsLeft = Infinity;

    for (const trip of TRIPS) {
        const target = new Date(trip.date);
        const msLeft = target - now;

        if (msLeft > 0 && msLeft < minMsLeft) {
            minMsLeft = msLeft;
            nextTrip = trip;
        }
    }

    const nextDestinationElement = document.getElementById('next-destination');
    if (nextTrip) {
        const odCard = getOriginDest(nextTrip.title);
        const targetDate = new Date(nextTrip.date);
        const dateStr = targetDate.toLocaleDateString('pt-BR');
        const timeStr = targetDate.toLocaleTimeString('pt-BR', {hour:'2-digit', minute:'2-digit'});
        
        let tripTitle;
        if (nextTrip.type === "cruise-stop" || nextTrip.type === "cruise-start" || nextTrip.type === "cruise-end") {
            tripTitle = odCard.to;
        } else {
            tripTitle = `${odCard.from} ‚Üí ${odCard.to}`;
        }
        
        nextDestinationElement.innerHTML = `Pr√≥ximo destino: <b>${tripTitle}</b> ‚Äî ${dateStr}, ${timeStr}`;
    } else {
        nextDestinationElement.textContent = "Todas as viagens foram conclu√≠das!";
    }
}

/**
 * Renderiza todos os cart√µes de viagem.
 */
function renderTrips() {
    const container = document.getElementById('trips-container');
    container.innerHTML = '';
    TRIPS.forEach(trip => {
        const card = createTripCard(trip);
        card.dataset.tripIndex = TRIPS.indexOf(trip);
        container.appendChild(card);
    });
}

/**
 * Atualiza o estado de todos os cart√µes de viagem.
 */
function updateAllCards() {
    const now = new Date();
    const cardElements = document.querySelectorAll('.trip-card');
    
    cardElements.forEach(cardElement => {
        const index = parseInt(cardElement.dataset.tripIndex);
        const trip = TRIPS[index];
        updateTripCard(cardElement, trip, now);
    });
    
    findNextTrip(now);
}

/**
 * Inicializa o widget.
 */
function init() {
    renderTrips();
    updateAllCards(); // Primeira atualiza√ß√£o imediata
    setInterval(updateAllCards, 1000); // Atualiza a cada segundo
}

// Inicia o widget quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
